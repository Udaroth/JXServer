The main function is called, and inside it handles reading the arguments directly into variables of appropriate sizes using fread. 

Setup of the network connection:
Next up we create the IP socket address struct, storing the given port and address into the struct. We initialise the sin_family variable to AF_INET which is just using the IPv4 protocols. Next up, we're going to initialise the serversocket_fd variable into a socket using the socket() function. Checking the if the serversocket_fd value is less than 0 will make sure the program exits if the initialisation failed. We don't need to perform any conversions between host and network byte orders because they are already sent in network byte order. We also set socket options for reuse port and reuse address to true, this will make it easier to perform testing and won't be blocked from using the same ports and addresses. Following up is the bind() call, this will bind the server socket file descriptor to the port. Finally, the listen() call will have the server begin listening to incoming connections on the given port and address, the second parameter is the queue of incoming connections and is arbitrary for the time being. 



How a connection is handled: 

A connection is handled in the while loop, using the accept() function we accept the connection and store socket id into the clientsocket_fd variable. Then we create a data_packet struct to store the client file descriptor into the socket_fd variable. Next up in the function called by pthread_create, we use a poll to timeout the thread if no data is received. Another while loop is used in here to allow the same client to make multiple requests sequentially. Recv is called at the start of each loop to check for the header byte, using the header byte we use different functions to extract the information in terms of request type, compression, and reply compression, and we store these into the struct. We perform another recv after to check and store payload length. Given the payload length, this allows us to read the appropriate number of bytes of the payload. We malloc space, and store the payload inside the struct. Lastly, at the bottom of the while loop, we call the appropriate function depending on the request type found in the header. The error function simply sets the type in the packet struct into 0xf and updates payload length to 0. Then using the packet_to_response function. It writes each of the packet component back through the socket_fd. The echo function sets the type to 0x1 using the set_type function I created, then again, writes it back to the relevant socket_fd using packet_to_response.

How multiple connections are handled: 
Multiple connections are handled in the while loop of the main function. The semaphore new_client will ensure that each client is initialised with the correct clientsocket_fd before the next connection overwrites the same variable. Each connection and their relevant requests are handled by a new pthread_create, hence allowing multiple connections at once. A thread pool is not yet implemented at this stage. 

